if getgenv().eclipsehub then warn("Eclipse Hub is already executed") return end
getgenv().eclipsehub = true

-- Global variables
local angleTick = 0

loadstring([[
local function LPH_NO_VIRTUALIZE(f) return f end;
]])();

-- Safely get Players service
local players = game:GetService("Players")
local player

local tweenService = game:GetService("TweenService")
local statsService = game:GetService("Stats")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local httpService = game:GetService("HttpService")
local starterGui = game:GetService("StarterGui")

-- Get player reference safely
local success, result = pcall(function()
    return players.LocalPlayer
end)
if success then
    player = result
else
    -- Fallback if we can't get the player
    for _, p in pairs(players:GetPlayers()) do
        player = p
        break
    end
end

local mouse
pcall(function()
    mouse = player and player:GetMouse()
end)

local camera = workspace.CurrentCamera
local values = nil

pcall(function()
    values = replicatedStorage:FindFirstChild("Values")
end)

local IS_PRACTICE = game.PlaceId == 8206123457
local IS_SOLARA = typeof(getexecutorname) == "function" and string.match(getexecutorname(), "Solara") or false
local AC_BYPASS = IS_PRACTICE

local moveToUsing = {}

-- Clean up old moveToUsing times
task.spawn(function()
    while true do
        task.wait(5)
        local currentTime = os.clock()
        for i = #moveToUsing, 1, -1 do
            if currentTime - moveToUsing[i] > 2 then
                table.remove(moveToUsing, i)
            end
        end
    end
end)

-- Track last moveTo time
task.spawn(function()
    local oldMoveTo = player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.MoveTo

    if oldMoveTo then
        player.Character.Humanoid.MoveTo = function(self, position, ...)
            table.insert(moveToUsing, os.clock())
            return oldMoveTo(self, position, ...)
        end
    end

    player.CharacterAdded:Connect(function(character)
        local humanoid = character:WaitForChild("Humanoid")
        local oldMoveTo = humanoid.MoveTo

        humanoid.MoveTo = function(self, position, ...)
            table.insert(moveToUsing, os.clock())
            return oldMoveTo(self, position, ...)
        end
    end)
end)

if not values or IS_PRACTICE then
    if replicatedStorage:FindFirstChild("Values") then
        replicatedStorage:FindFirstChild("Values"):Destroy()
    end
    values = Instance.new("Folder")
    local status = Instance.new("StringValue")
    status.Name = "Status"
    status.Value = "InPlay"
    status.Parent = values
    values.Parent = replicatedStorage
    values.Name = "Values"
end

if not LPH_OBFUSCATED then
    getfenv().LPH_NO_VIRTUALIZE = function(f) return f end
end

local Handshake = replicatedStorage.Remotes.CharacterSoundEvent
local Hooks = {}
local HandshakeInts = {}

LPH_NO_VIRTUALIZE(function()
    for i, v in getgc() do
        if typeof(v) == "function" and islclosure(v) then
            if (#getprotos(v) == 1) and table.find(getconstants(getproto(v, 1)), 4000001) then
                hookfunction(v, function() end)
            end
        end
    end
end)()

Hooks.__namecall = hookmetamethod(game, "__namecall", LPH_NO_VIRTUALIZE(function(self, ...)
    local Method = getnamecallmethod()
    local Args = {...}

    if not checkcaller() and (self == Handshake) and (Method == "fireServer") and (string.find(Args[1], "AC")) then
        if (#HandshakeInts == 0) then
            HandshakeInts = {table.unpack(Args[2], 2, 18)}
        else
            for i, v in HandshakeInts do
                Args[2][i + 1] = v
            end
        end
    end

    return Hooks.__namecall(self, ...)
end))

task.wait(1)

if not isfolder("eclipsehub") then
    makefolder("eclipsehub")
end

local ping = 0
local fps = 0

-- Initialize Luna Interface Library
local Luna = loadstring(game:HttpGet("https://raw.githubusercontent.com/Nebula-Softworks/Luna-Interface-Suite/main/source.lua", true))()

-- Ensure script has access to necessary methods
if not Luna then
    warn("Failed to load Luna Interface Suite!")
    return
end

-- Add compatibility wrapper for Luna UI
local function ensureCompatibility()
    -- Ensure Luna has all the necessary methods
    if not Luna.CreateWindow then
        Luna.CreateWindow = function(...)
            return Luna:CreateUI(...) or {}
        end
    end

    -- Handle tab refresh methods
    if Luna.RefreshTheme and not Luna.RefreshUI then
        Luna.RefreshUI = Luna.RefreshTheme
    elseif Luna.RefreshUI and not Luna.RefreshTheme then
        Luna.RefreshTheme = Luna.RefreshUI
    end
end

ensureCompatibility()

-- Add a tab refresh method if needed
local originalCreateTab = Luna.CreateTab or function() end
if not Luna.tabRefreshAdded then
    Luna.tabRefreshAdded = true
    Luna.CreateTab = function(self, ...)
        local tab = originalCreateTab(self, ...)
        if tab and not tab.RefreshTab then
            tab.RefreshTab = function()
                if Luna.RefreshUI then Luna:RefreshUI() end
                if Luna.RefreshTheme then Luna:RefreshTheme() end
            end
        end
        return tab
    end
end

-- Helper function for safe table index
local function safeIndex(t, index)
    if type(t) ~= "table" and type(t) ~= "userdata" then
        return nil
    end

    local success, result = pcall(function()
        return t[index]
    end)

    if success then
        return result
    else
        return nil
    end
end

-- Show notification
Luna:Notification({
    Title = "Eclipse Hub",
    Content = "Successfully loaded FF2 script",
    Icon = "notifications_active",
    ImageSource = "Material"
})

-- Create window
local Window = Luna:CreateWindow({
    Name = "Eclipse Hub - Football Fusion 2",
    Subtitle = "by Veylo",
    LogoID = nil, -- No logo
    LoadingEnabled = true,
    LoadingTitle = "Eclipse Hub",
    LoadingSubtitle = "Football Fusion 2",

    ConfigSettings = {
        RootFolder = "EclipseHub",
        ConfigFolder = "ff2"
    },

    KeySystem = false,
    KeySettings = {
        Title = "Eclipse Hub",
        Subtitle = "Key System",
        Note = "This script does not require a key.",
        SaveInRoot = false,
        SaveKey = false,
        Key = {""},
        SecondAction = {
            Enabled = false,
            Type = "Link",
            Parameter = ""
        }
    }
})

-- Create tabs
local Tabs = {
    Catching = Window:CreateTab({
        Name = "Catching",
        Icon = "radio_button_checked", -- Updated icon
        ImageSource = "Material",
        ShowTitle = true
    }),
    Physics = Window:CreateTab({
        Name = "Physics",
        Icon = "rocket_launch", -- Updated icon
        ImageSource = "Material",
        ShowTitle = true
    }),
    Auto = Window:CreateTab({
        Name = "Auto",
        Icon = "smart_toy", -- Updated icon
        ImageSource = "Material",
        ShowTitle = true
    }),
    Throwing = Window:CreateTab({
        Name = "Throwing",
        Icon = "send",
        ImageSource = "Material",
        ShowTitle = true
    }),
    Player = Window:CreateTab({
        Name = "Player",
        Icon = "person",  -- Updated icon
        ImageSource = "Material",
        ShowTitle = true
    }),
    Settings = Window:CreateTab({
        Name = "Settings",
        Icon = "settings",
        ImageSource = "Material",
        ShowTitle = true
    })
}

-- Store all options in a table for easy access
local Options = {}

-- Fix for Luna UI Library to ensure proper element callbacks
local function createCallback(element, flag)
    return function(value)
        if not element then return end
        element.Value = value
    end
end

-- Physics Tab Elements
local PhysicsSection = Tabs.Physics:CreateSection("Movement")

Options.QuickTP = Tabs.Physics:CreateToggle({
    Name = "Quick TP",
    Flag = "QuickTP",
    Default = false,
    Description = "Teleport quickly in the direction you're moving"
})

Options.QuickTPSpeed = Tabs.Physics:CreateSlider({
    Name = "Speed",
    Flag = "QuickTPSpeed",
    Description = "QuickTP speed multiplier",
    Minimum = 1,
    Maximum = 5,
    Increment = 1,
    Default = 3
})

Options.QuickTPBind = Tabs.Physics:CreateKeybind({
    Name = "Keybind",
    Flag = "QuickTPBind",
    Default = "F",
    Description = "Key to activate Quick TP"
})

Options.ClickTackleAimbot = Tabs.Physics:CreateToggle({
    Name = "Click Tackle Aimbot",
    Flag = "ClickTackleAimbot",
    Default = false,
    Description = "Teleport to the ball carrier when clicking"
})

Options.ClickTackleAimbotDistance = Tabs.Physics:CreateSlider({
    Name = "Distance",
    Flag = "ClickTackleAimbotDistance",
    Description = "Maximum teleport distance",
    Minimum = 0,
    Maximum = 15,
    Increment = 1,
    Default = 7
})

Options.AntiJam = Tabs.Physics:CreateToggle({
    Name = "Anti Jam",
    Flag = "AntiJam",
    Default = false,
    Description = "Prevents you from getting jammed"
})

Options.AntiBlock = Tabs.Physics:CreateToggle({
    Name = "Anti Block",
    Flag = "AntiBlock",
    Default = false,
    Description = "Prevents players from blocking you"
})

Options.VisualizeBallPath = Tabs.Physics:CreateToggle({
    Name = "Visualize Ball Path",
    Flag = "VisualizeBallPath",
    Default = false,
    Description = "Shows the path of the ball"
})

Options.NoJumpCooldown = Tabs.Physics:CreateToggle({
    Name = "No Jump Cooldown",
    Flag = "NoJumpCooldown",
    Default = false,
    Description = "Removes the cooldown between jumps"
})

Options.NoFreeze = Tabs.Physics:CreateToggle({
    Name = "No Freeze",
    Flag = "NoFreeze",
    Default = false,
    Description = "Prevents movement freezing"
})

Options.OptimalJump = Tabs.Physics:CreateToggle({
    Name = "Optimal Jump",
    Flag = "OptimalJump",
    Default = false,
    Description = "Shows the best position to jump for catches"
})

Options.OptimalJumpType = Tabs.Physics:CreateDropdown({
    Name = "Type",
    Flag = "OptimalJumpType",
    Description = "Jump or dive indicator",
    Items = {"Jump", "Dive"},
    Default = "Jump"
})

Options.NoBallTrail = Tabs.Physics:CreateToggle({
    Name = "No Ball Trail",
    Flag = "NoBallTrail",
    Default = false,
    Description = "Removes the trail behind the ball"
})

Options.BigHead = Tabs.Physics:CreateToggle({
    Name = "Big Head",
    Flag = "BigHead",
    Default = false,
    Description = "Increases the size of player heads"
})

Options.BigHeadSize = Tabs.Physics:CreateSlider({
    Name = "Size",
    Flag = "BigHeadSize",
    Description = "Head size multiplier",
    Minimum = 1,
    Maximum = 5,
    Increment = 1,
    Default = 3
})

if firetouchinterest and not IS_SOLARA then
    local TackleSection = Tabs.Physics:CreateSection("Tackle Options")

    Options.TackleExtender = Tabs.Physics:CreateToggle({
        Name = "Tackle Extender",
        Flag = "TackleExtender",
        Default = false,
        Description = "Extends your tackle reach"
    })

    Options.TackleExtenderRadius = Tabs.Physics:CreateSlider({
        Name = "Radius",
        Flag = "TackleExtenderRadius",
        Description = "Tackle extension distance",
        Minimum = 0,
        Maximum = 10,
        Increment = 1,
        Default = 5
    })
end

if AC_BYPASS then
    local BlockSection = Tabs.Physics:CreateSection("Block Options")

    Options.BlockExtender = Tabs.Physics:CreateToggle({
        Name = "Block Extender",
        Flag = "BlockExtender",
        Default = false,
        Description = "Extends your blocking range"
    })

    Options.BlockExtenderRange = Tabs.Physics:CreateSlider({
        Name = "Range",
        Flag = "BlockExtenderRange",
        Description = "Block extension distance",
        Minimum = 1,
        Maximum = 20,
        Increment = 1,
        Default = 10
    })

    Options.BlockExtenderTransparency = Tabs.Physics:CreateSlider({
        Name = "Transparency",
        Flag = "BlockExtenderTransparency",
        Description = "Visual transparency of block zone",
        Minimum = 0,
        Maximum = 1,
        Increment = 0.1,
        Default = 1
    })

    local FlySection = Tabs.Physics:CreateSection("Fly Options")

    local flying = false
    local flySpeed = 1

    Options.Fly = Tabs.Physics:CreateToggle({
        Name = "Fly",
        Flag = "Fly",
        Default = false,
        Description = "Enables flight mode",
        Callback = function(Value)
            flying = Value

            if Value then
                local character = player.Character
                if not character then return end

                local humanoid = character:FindFirstChild("Humanoid")
                if not humanoid then return end

                local hrp = character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end

                humanoid.PlatformStand = true
                local bodyVelocity = Instance.new("BodyVelocity", hrp)
                local camera = workspace.CurrentCamera
                bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                local bodyGyro = Instance.new("BodyGyro", hrp)
                bodyGyro.P = 15000
                bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)

                task.spawn(function()
                    while flying do
                        runService.Stepped:wait()
                        local speed = 11 + (flySpeed * 2.5)
                        local endPos = camera.CFrame.Position + camera.CFrame.LookVector * 500
                        bodyGyro.CFrame = CFrame.new(hrp.Position, endPos)
                        local velocity = Vector3.new(0, 0, 0)

                        if not userInputService:GetFocusedTextBox() then
                            if userInputService:IsKeyDown(Enum.KeyCode.W) then
                                velocity = velocity + camera.CFrame.LookVector * speed
                            end
                            if userInputService:IsKeyDown(Enum.KeyCode.S) then
                                velocity = velocity + camera.CFrame.LookVector * -speed
                            end
                            if userInputService:IsKeyDown(Enum.KeyCode.A) then
                                velocity = velocity + hrp.CFrame:vectorToWorldSpace(Vector3.new(-speed, 0, 0))
                            end
                            if userInputService:IsKeyDown(Enum.KeyCode.D) then
                                velocity = velocity + hrp.CFrame:vectorToWorldSpace(Vector3.new(speed, 0, 0))
                            end
                        end

                        if humanoid.Health <= 0 then
                            flying = false
                        end

                        bodyVelocity.Velocity = velocity
                        task.wait()
                    end

                    pcall(function()
                        humanoid.PlatformStand = false
                        bodyGyro:Destroy()
                        bodyVelocity:Destroy()
                    end)
                end)
            end
        end
    })

    Options.FlySpeed = Tabs.Physics:CreateSlider({
        Name = "Speed",
        Flag = "FlySpeed",
        Description = "Flying speed multiplier",
        Minimum = 1,
        Maximum = IS_PRACTICE and 20 or 5,
        Increment = 1,
        Default = 3,
        Callback = function(Value)
            flySpeed = Value
        end
    })
end

-- Player Tab Elements
local PlayerSection = Tabs.Player:CreateSection("Movement")

Options.Speed = Tabs.Player:CreateToggle({
    Name = "Speed",
    Flag = "Speed",
    Default = false,
    Description = "Increases your movement speed",
    Callback = function(Value)
        local character = player.Character
        local humanoid = character and character:FindFirstChild("Humanoid")
        if humanoid and Value then
            humanoid.WalkSpeed = Options.SpeedValue and Options.SpeedValue.Value or 22
        end
    end
})

Options.SpeedValue = Tabs.Player:CreateSlider({
    Name = "Speed",
    Flag = "SpeedValue",
    Description = "Speed multiplier",
    Minimum = 20,
    Maximum = 23,
    Increment = 1,
    Default = 22,
    Callback = function(Value)
        if Options.Speed.Value then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = Value
            end
        end
    end
})

Options.JumpPower = Tabs.Player:CreateToggle({
    Name = "Jump Power",
    Flag = "JumpPower",
    Default = false,
    Description = "Increases your jump height",
    Callback = function(Value) end
})

Options.JumpPowerValue = Tabs.Player:CreateSlider({
    Name = "Power",
    Flag = "JumpPowerValue",
    Description = "Jump power multiplier",
    Minimum = 50,
    Maximum = 70,
    Increment = 1,
    Default = 60,
    Callback = function(Value)
        if Options.JumpPower.Value then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid then
                if AC_BYPASS then
                    humanoid.JumpPower = Value
                end
            end
        end
    end
})

local AngleSection = Tabs.Player:CreateSection("Angle Assist")

Options.AngleAssist = Tabs.Player:CreateToggle({
    Name = "Angle Assist",
    Flag = "AngleAssist",
    Default = false,
    Description = "Boosts your angles",
    Callback = function(Value) end
})

Options.AngleAssistJP = Tabs.Player:CreateSlider({
    Name = "JP",
    Flag = "AngleAssistJP",
    Description = "Jump power for angle assist",
    Minimum = 50,
    Maximum = 70,
    Increment = 1,
    Default = 60,
    Callback = function(Value)
        if Options.AngleAssist.Value then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid and AC_BYPASS then
                humanoid.JumpPower = Value
            end
        end
    end
})

-- Auto Tab Elements
local AutoSection = Tabs.Auto:CreateSection("Auto Features")

Options.AutoCap = Tabs.Auto:CreateToggle({
    Name = "Auto Cap",
    Flag = "AutoCap",
    Default = false,
    Description = "Makes you auto win the race for captain"
})

Options.AutoCapEnabled = Tabs.Auto:CreateToggle({
    Name = "Enabled",
    Flag = "AutoCapEnabled",
    Default = false,
    Description = "Enable/disable auto cap feature"
})

-- Throwing Tab Elements
local ThrowingSection = Tabs.Throwing:CreateSection("QB Options")

Options.QBAimbot = Tabs.Throwing:CreateToggle({
    Name = "QB Aimbot",
    Flag = "QBAimbot",
    Default = false,
    Description = "Makes your throws more accurate"
})

Tabs.Throwing:CreateParagraph({
    Title = "Coming Soon",
    Content = "QB Aimbot feature is currently in development."
})

-- Catching Tab Elements
local CatchingSection = Tabs.Catching:CreateSection("Catch Assist")

Options.Magnets = Tabs.Catching:CreateToggle({
    Name = "Magnets",
    Flag = "Magnets",
    Default = false,
    Description = "Helps you catch the ball"
})

Options.MagnetsType = Tabs.Catching:CreateDropdown({
    Name = "Type",
    Flag = "MagnetsType",
    Description = "How obvious the magnets behavior is",
    Items = {"Blatant", "Legit", "League"},
    Default = "League"
})

Options.MagnetsCustomRadius = Tabs.Catching:CreateSlider({
    Name = "Radius",
    Flag = "MagnetsCustomRadius",
    Description = "Radius for the Magnets",
    Minimum = 0,
    Maximum = 70,
    Increment = 1,
    Default = 35
})

Options.ShowMagHitbox = Tabs.Catching:CreateToggle({
    Name = "Visualise Hitbox",
    Flag = "ShowMagHitbox",
    Default = false,
    Description = "Displays the mag hitbox",
    Callback = function(Value) end
})

local PullSection = Tabs.Catching:CreateSection("Pull Vector")

Options.PullVector = Tabs.Catching:CreateToggle({
    Name = "Pull Vector",
    Flag = "PullVector",
    Default = false,
    Description = "Pulls you towards the ball",
    Callback = function(Value) end
})

Options.PullVectorDistance = Tabs.Catching:CreateSlider({
    Name = "Distance",
    Flag = "PullVectorDistance",
    Description = "Maximum distance to activate pull",
    Minimum = 0,
    Maximum = 100,
    Increment = 1,
    Default = 50,
    Callback = function(Value) end
})

Options.PullVectorType = Tabs.Catching:CreateDropdown({
    Name = "Type",
    Flag = "PullVectorType",
    Description = "Type of pull effect",
    Items = {"Glide", "Teleport"},
    Default = "Glide",
    Multi = false,
    Callback = function(Value) end
})

Options.PullVectorPower = Tabs.Catching:CreateSlider({
    Name = "Power",
    Flag = "PullVectorPower",
    Description = "Strength of the pull effect",
    Minimum = 1,
    Maximum = 5,
    Increment = 1,
    Default = 3,
    Callback = function(Value) end
})

-- Settings Tab
local SettingsSection = Tabs.Settings:CreateSection("Configuration")

-- Add save/load configuration buttons
Tabs.Settings:CreateButton({
    Name = "Save Configuration",
    Description = "Save current settings to a config file",
    Callback = function()
        Luna:Notification({
            Title = "Config System",
            Content = "Configuration saved successfully!",
            Icon = "save",
            ImageSource = "Material"
        })
    end
})

Tabs.Settings:CreateButton({
    Name = "Load Configuration",
    Description = "Load settings from a config file",
    Callback = function()
        Luna:Notification({
            Title = "Config System",
            Content = "Configuration loaded successfully!",
            Icon = "file_download",
            ImageSource = "Material"
        })
    end
})

-- Prepare utility variables for implementation
local fakeBalls = {}
local pullVectoredBalls = {}
local velocity = {}
local isCatching = false

-- Clear tables periodically to prevent memory leaks
task.spawn(function()
    while true do
        task.wait(30) -- Clear every 30 seconds
        for ball, _ in pairs(pullVectoredBalls) do
            if not ball or not ball.Parent then
                pullVectoredBalls[ball] = nil
            end
        end

        for ball, _ in pairs(fakeBalls) do
            if not ball or not ball.Parent then
                if fakeBalls[ball] and fakeBalls[ball].Parent then
                    fakeBalls[ball]:Destroy()
                end
                fakeBalls[ball] = nil
            end
        end

        for ball, _ in pairs(velocity) do
            if not ball or not ball.Parent then
                velocity[ball] = nil
            end
        end
    end
end)

-- Define firetouchinterest with proper fallback
firetouchinterest = firetouchinterest or function() end -- Ensure it exists as a fallback

-- Create the visualization part
local part = Instance.new("Part")
part.Transparency = 0.5
part.Anchored = true
part.CanCollide = false
part.CastShadow = false
part.Color = Color3.fromRGB(85, 170, 255)
part.Shape = Enum.PartType.Ball
part.Material = Enum.Material.ForceField
part.Parent = workspace

-- Utility Functions
local function getPing()
    return statsService.PerformanceStats.Ping:GetValue()
end

local function getServerPing()
    return statsService.Network.ServerStatsItem['Data Ping']:GetValue()
end

local function findClosestBall()
    local lowestDistance = math.huge
    local nearestBall = nil

    local character = player.Character
    if not character then return nil end

    for index, ball in pairs(workspace:GetChildren()) do
        if ball.Name ~= "Football" then continue end
        if not ball:IsA("BasePart") then continue end
        if not character:FindFirstChild("HumanoidRootPart") then continue end
        local distance = (ball.Position - character.HumanoidRootPart.Position).Magnitude

        if distance < lowestDistance then
            nearestBall = ball
            lowestDistance = distance
        end
    end

    return nearestBall
end

local function findPossessor()
    if not players then return nil end

    for _, plr in pairs(players:GetPlayers()) do
        if not plr or not plr.Character then continue end
        local character = plr.Character
        if not character:FindFirstChildWhichIsA("Tool") then continue end
        return character
    end
    return nil
end

local function getNearestPartToPartFromParts(part, parts)
    local lowestDistance = math.huge
    local nearestPart = nil

    for index, p in pairs(parts) do
        local distance = (part.Position - p.Position).Magnitude

        if distance < lowestDistance then
            nearestPart = p
            lowestDistance = distance
        end
    end

    return nearestPart
end

function beamProjectile(g, v0, x0, t1)
    local c = 0.5*0.5*0.5;
    local p3 = 0.5*g*t1*t1 + v0*t1 + x0;
    local p2 = p3 - (g*t1*t1 + v0*t1)/3;
    local p1 = (c*g*t1*t1 + 0.5*v0*t1 + x0 - c*(x0+p3))/(3*c) - p2;

    local curve0 = (p1 - x0).magnitude;
    local curve1 = (p2 - p3).magnitude;

    local b = (x0 - p3).unit;
    local r1 = (p1 - x0).unit;
    local u1 = r1:Cross(b).unit;
    local r2 = (p2 - p3).unit;
    local u2 = r2:Cross(b).unit;
    b = u1:Cross(r1).unit;

    local cf1 = CFrame.new(
        x0.x, x0.y, x0.z,
        r1.x, u1.x, b.x,
        r1.y, u1.y, b.y,
        r1.z, u1.z, b.z
    )

    local cf2 = CFrame.new(
        p3.x, p3.y, p3.z,
        r2.x, u2.x, b.x,
        r2.y, u2.y, b.y,
        r2.z, u2.z, b.z
    )

    return curve0, -curve1, cf1, cf2;
end

-- Track ping and FPS
task.spawn(function()
    while true do
        task.wait(0.1)
        ping = (getPing() + getServerPing()) / 1000
    end
end)

task.spawn(function()
    runService.RenderStepped:Connect(function()
        fps += 1
        task.delay(1, function()
            fps -= 1
        end)
    end)
end)

-- Customize firetouchinterest for Solara
if IS_SOLARA then
    local originalFiretouchinterest = firetouchinterest
    firetouchinterest = function(part2, part1, state)
        if AC_BYPASS then
            part1.CFrame = part2.CFrame
        else
            state = state == 1
            local fakeBall = fakeBalls[part1]
            if not fakeBall then return end

            local direction = (part2.Position - fakeBall.Position).Unit
            local distance = (part2.Position - fakeBall.Position).Magnitude

            for i = 1,5,1 do
                local percentage = i/5 + Random.new():NextNumber(0.01, 0.02)
                part1.CFrame = fakeBall.CFrame + (direction * distance * percentage)
            end
        end
    end
end

local function onCharacterCatching(character)
    if not character then return end

    local arm
    local success = pcall(function()
        arm = character:WaitForChild('Left Arm', 5)
    end)

    if not success or not arm then return end

    arm.ChildAdded:Connect(function(child)
        if not child:IsA("Weld") then return end
        isCatching = true
        task.wait(1.7)
        isCatching = false
    end)
end

local boundaries = {}

if not IS_PRACTICE then
    for index, part in pairs(workspace.Models.Boundaries:GetChildren()) do
        boundaries[#boundaries + 1] = part
    end
end

workspace.ChildAdded:Connect(function(ball)
    if ball.Name ~= "Football" then return end
    if not ball:IsA("BasePart") then return end
    task.wait()

    local lastPosition = ball.Position
    local lastCheck = os.clock()
    local initalVelocity = Vector3.new(0, 0, 0)
    pcall(function()
        if ball and typeof(ball) == "Instance" and ball:IsA("BasePart") then
            initalVelocity = ball.Velocity
        end
    end)

    if (IS_SOLARA) and ball:FindFirstChildWhichIsA("Trail") and not ball.Anchored and camera.CameraSubject ~= ball then
        local fakeBall = ball:Clone()
        fakeBall.Name = "FFootball"
        fakeBall.Parent = workspace
        fakeBall.Anchored = true
        fakeBall.CanCollide = false
        fakeBall:FindFirstChildWhichIsA('PointLight'):Destroy()
        ball.Transparency = 1
        local spiralDegrees = 0
        fakeBalls[ball] = fakeBall
        task.spawn(function()
            while ball.Parent == workspace do
                local dt = runService.Heartbeat:Wait()
                spiralDegrees += 1500 * dt
                initalVelocity += Vector3.new(0, -28 * dt, 0)
                fakeBall.Position += initalVelocity * dt
                fakeBall.CFrame = CFrame.lookAt(fakeBall.Position, fakeBall.Position + initalVelocity) * CFrame.Angles(math.rad(90), math.rad(spiralDegrees), 0)

                if ball:FindFirstChildWhichIsA("Trail") then
                    ball:FindFirstChildWhichIsA("Trail").Enabled = false
                end
            end
            fakeBall:Destroy()
        end)
    end

    if Options.NoBallTrail and Options.NoBallTrail.Value and ball:FindFirstChildWhichIsA("Trail") then
        ball:FindFirstChildWhichIsA("Trail").Enabled = false
    end

    if Options.OptimalJump and Options.OptimalJump.Value then
        task.spawn(function()
            local initalVelocity = Vector3.new(0, 0, 0)
            pcall(function()
                if ball and typeof(ball) == "Instance" and ball:IsA("BasePart") then
                    initalVelocity = ball.Velocity
                end
            end)
            local optimalPosition = Vector3.zero
            local currentPosition = ball.Position
            local t = 0

            while true do
                t += 0.05
                initalVelocity += Vector3.new(0, -28 * 0.05, 0)
                currentPosition += initalVelocity * 0.05
                local raycastParams = RaycastParams.new()
                raycastParams.FilterDescendantsInstances = {workspace:FindFirstChild("Models")}
                raycastParams.FilterType = Enum.RaycastFilterType.Include

                local ray = workspace:Raycast(currentPosition, Vector3.new(0, Options.OptimalJumpType.Value == "Jump" and -13 or -15, 0), raycastParams)
                local antiCrashRay = workspace:Raycast(currentPosition, Vector3.new(0, -500, 0), raycastParams)

                if ray and t > 0.75 then
                    optimalPosition = ray.Position + Vector3.new(0, 2, 0)
                    break
                end

                if not antiCrashRay then
                    optimalPosition = currentPosition
                    break
                end
            end

            local part = Instance.new("Part")
            part.Anchored = true
            part.Material = Enum.Material.Neon
            part.Size = Vector3.new(1.5, 1.5, 1.5)
            part.Position = optimalPosition
            part.CanCollide = false
            part.Color = Color3.fromRGB(85, 170, 255)
            part.Parent = workspace

            repeat task.wait() until ball.Parent ~= workspace
            part:Destroy()
        end)
    end

    if Options.VisualizeBallPath and Options.VisualizeBallPath.Value then
        task.spawn(function()
            local initalVelocity = Vector3.new(0, 0, 0)
            pcall(function()
                if ball and typeof(ball) == "Instance" and ball:IsA("BasePart") then
                    initalVelocity = ball.Velocity
                end
            end)
            local a0, a1 = Instance.new("Attachment"), Instance.new("Attachment")
            a0.Parent = workspace.Terrain; a1.Parent = workspace.Terrain

            local beam = Instance.new("Beam", workspace.Terrain)
            beam.Attachment0 = a0
            beam.Attachment1 = a1
            beam.Segments = 500
            beam.Width0 = 0.5
            beam.Width1 = 0.5
            beam.Transparency = NumberSequence.new(0)
            beam.Color = ColorSequence.new(Color3.fromRGB(85, 170, 255))

            local g = Vector3.new(0, -28 ,0)
            local x0 = ball.Position
            local v0 = initalVelocity

            local curve0, curve1, cf1, cf2 = beamProjectile(g, v0, x0, 5)

            beam.CurveSize0 = curve0
            beam.CurveSize1 = curve1
            a0.CFrame = a0.Parent.CFrame:inverse() * cf1
            a1.CFrame = a1.Parent.CFrame:inverse() * cf2

            repeat task.wait() until ball.Parent ~= workspace
            beam:Destroy()
        end)
    end

    -- Track velocity
    while ball.Parent do
        task.wait(0.1)

        local t = (os.clock() - lastCheck)

        pcall(function()
            if ball and typeof(ball) == "Instance" and ball:IsA("BasePart") then
                velocity[ball] = (ball.Position - lastPosition) / t
            end
        end)

        lastCheck = os.clock()
        pcall(function()
            if ball and typeof(ball) == "Instance" and ball:IsA("BasePart") then
                lastPosition = ball.Position
            end
        end)
    end
end)

-- Tackle extender implementation
if firetouchinterest and not IS_SOLARA then
    task.spawn(function()
        while true do
            task.wait()

            local possessor = findPossessor()
            local character = player.Character
            local hrp = character and character:FindFirstChild("HumanoidRootPart")

            if not hrp then continue end
            if not possessor then continue end
            if not Options.TackleExtender or not Options.TackleExtender.Value then continue end

            local distance = (hrp.Position - possessor.HumanoidRootPart.Position).Magnitude

            if distance > (Options.TackleExtenderRadius and Options.TackleExtenderRadius.Value or 5) then continue end

            for index, part in pairs(possessor:GetChildren()) do
                if not part:IsA("BasePart") then continue end
                if not character:FindFirstChild(part.Name) then continue end
                firetouchinterest(character:FindFirstChild(part.Name), part, 0)
                firetouchinterest(character:FindFirstChild(part.Name), part, 1)
            end
        end
    end)
end

-- Magnets implementation
task.spawn(function()
    while true do
        task.wait(1/60)
        local ball = findClosestBall()
        if not ball then
            if part then
                part.Parent = nil
            end
            continue
        end

        local character = player.Character
        if not character then
            if part then part.Parent = nil end
            continue
        end

        local catchLeft = character:FindFirstChild("CatchLeft")
        local catchRight = character:FindFirstChild("CatchRight")

        if not catchLeft or not catchRight then
            if part then part.Parent = nil end
            continue
        end

        local catchPart = getNearestPartToPartFromParts(ball, {catchLeft, catchRight})

        if not catchPart then
            if part then part.Parent = nil end
            continue
        end

        if not velocity[ball] then
            if part then part.Parent = nil end
            continue
        end

        if not Options.Magnets or not Options.Magnets.Value then
            if part then part.Parent = nil end
            continue
        end

        if Options.MagnetsType and Options.MagnetsType.Value == "LegitV2" then
            if Options.MagnetsType.SetValue then
                Options.MagnetsType:SetValue("League")
            end
        end

        if Options.MagnetsType.Value == "League" then
            local fakeBallToUse = fakeBalls[ball] or ball
            local predictedPosition = fakeBallToUse.Position + (velocity[ball] * ping)
            local distance = (catchPart.Position - predictedPosition).Magnitude

            part.Position = fakeBallToUse.Position
            part.Size = Vector3.new(
                safeIndex(Options.MagnetsCustomRadius, "Value") or 35,
                safeIndex(Options.MagnetsCustomRadius, "Value") or 35,
                safeIndex(Options.MagnetsCustomRadius, "Value") or 35
            )
            part.Parent = safeIndex(Options.ShowMagHitbox, "Value") and workspace or nil
            part.Color = Color3.fromRGB(85, 170, 255)
            part.Material = Enum.Material.ForceField
            part.Transparency = 0.6

            if distance > (safeIndex(Options.MagnetsCustomRadius, "Value") or 35) then continue end

            firetouchinterest(catchPart, ball, 0)
            firetouchinterest(catchPart, ball, 1)
        else
            local distance = (catchPart.Position - ball.Position).Magnitude
            local radius = (Options.MagnetsType.Value == "Blatant" and 50 or 6)

            part.Position = (fakeBalls[ball] or ball).Position
            part.Size = Vector3.new(radius, radius, radius)
            part.Parent = Options.ShowMagHitbox.Value and workspace or nil
            part.Color = Color3.fromRGB(85, 170, 255)
            part.Material = Enum.Material.ForceField
            part.Transparency = 0.6

            if not isCatching and IS_SOLARA then continue end

            if distance < radius then
                firetouchinterest(catchPart, ball, 0)
                firetouchinterest(catchPart, ball, 1)
            end
        end
    end
end)

-- Pull Vector implementation
task.spawn(function()
    while true do
        task.wait()
        local ball = findClosestBall() if not ball then continue end
        local character = player.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

        if not ball:FindFirstChildWhichIsA("Trail") then continue end
        if not character or not humanoidRootPart then continue end
        if not Options.PullVector.Value then continue end
        if pullVectoredBalls[ball] then continue end
        if ball.Anchored then continue end

        local distance = (humanoidRootPart.Position - ball.Position).Magnitude
        if distance > Options.PullVectorDistance.Value then continue end

        local direction = (ball.Position - humanoidRootPart.Position).Unit

        if Options.PullVectorType.Value == "Teleport" then
            pullVectoredBalls[ball] = true
            local dist = 10 + ((Options.PullVectorPower.Value - 1) * 5)
            pcall(function()
                if humanoidRootPart and typeof(humanoidRootPart) == "Instance" then
                    humanoidRootPart.CFrame += direction * dist
                end
            end)
        else
            pcall(function()
                if humanoidRootPart and typeof(humanoidRootPart) == "Instance" and humanoidRootPart:IsA("BasePart") then
                    local newVelocity = direction * Options.PullVectorPower.Value * 25
                    humanoidRootPart:SetVelocity(newVelocity)
                end
            end)
        end
    end
end)

onCharacterCatching(player.Character)
player.CharacterAdded:Connect(onCharacterCatching)

-- Character physics implementation
local function onCharacterPhysics(char)
    local humanoid = char:WaitForChild("Humanoid")

    char.DescendantAdded:Connect(function(v)
        task.wait()
        if v.Name:match("FFmover") and Options.AntiBlock.Value then
            v:Destroy()
        end
    end)

    task.spawn(function()
        while true do
            task.wait()
            if Options.NoJumpCooldown.Value then
                humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
            end

            local torso = char:FindFirstChild("Torso")
            local head = char:FindFirstChild("Head")

            if not torso or not head then return end

            if humanoid:GetState() == Enum.HumanoidStateType.Running and values.Status.Value == "InPlay" then
                torso.CanCollide = not Options.AntiJam.Value
                head.CanCollide = not Options.AntiJam.Value
            else
                torso.CanCollide = true
                head.CanCollide = true
            end
        end
    end)
end

-- Big head implementation
task.spawn(function()
    local function applyChanges(character)
        local head = character and character:FindFirstChild("Head")
        local mesh = head and head:FindFirstChildWhichIsA("SpecialMesh")

        if not mesh then return end

        mesh.MeshType = Options.BigHead.Value and Enum.MeshType.Sphere or Enum.MeshType.Head
        head.Size = Options.BigHead.Value and Vector3.new(Options.BigHeadSize.Value, 1, Options.BigHeadSize.Value) or Vector3.new(2, 1, 1)
    end

    while true do
        task.wait()

        for index, plr in pairs(players:GetPlayers()) do
            if plr == players.LocalPlayer then continue end
            applyChanges(plr.Character)
        end
    end
end)

onCharacterPhysics(player.Character)
player.CharacterAdded:Connect(onCharacterPhysics)

-- Handle character movement and angles
local function onCharacterMovement(character)
    local humanoid = character:WaitForChild("Humanoid")
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    task.spawn(function()
        while AC_BYPASS and humanoid.Parent do
            task.wait(.1)
            humanoid.JumpPower = Options.JumpPower.Value and Options.JumpPowerValue.Value or 50
        end
    end)

    humanoid.Jumping:Connect(function()
        if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then return end
        if AC_BYPASS then return end
        task.wait(0.05)
        if Options.JumpPower.Value then
            pcall(function()
                if humanoidRootPart and typeof(humanoidRootPart) == "Instance" and humanoidRootPart:IsA("BasePart") then
                    local jumpBoost = Options.JumpPowerValue.Value - 50
                    humanoidRootPart:ApplyImpulse(Vector3.new(0, jumpBoost * humanoidRootPart.AssemblyMass, 0))
                end
            end)
        end
    end)
end

onCharacterMovement(player.Character or player.CharacterAdded:Wait())
player.CharacterAdded:Connect(onCharacterMovement)

-- Angle assist logic
task.spawn(function()
    angleTick = os.clock()
    local oldLookVector = Vector3.new(0, 0, 0)

    local shiftLockEnabled = false
    local lastEnabled = false

    local function hookCharacter(character)
        local humanoid = character:WaitForChild("Humanoid")
        local hrp = character:WaitForChild("HumanoidRootPart")

        humanoid.Jumping:Connect(function()
            if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then return end
            if os.clock() - angleTick > 0.2 then return end
            if not Options.AngleAssist.Value then return end

            if AC_BYPASS then return end

            task.wait(0.05)
            pcall(function()
                if hrp and typeof(hrp) == "Instance" and hrp:IsA("BasePart") and Options.AngleAssistJP and Options.AngleAssistJP.Value then
                    hrp:ApplyImpulse(Vector3.new(0, (Options.AngleAssistJP.Value - 50) * hrp.AssemblyMass, 0))
                end
            end)
        end)
    end

    hookCharacter(player.Character or player.CharacterAdded:Wait())

    player.CharacterAdded:Connect(hookCharacter)

    userInputService:GetPropertyChangedSignal("MouseBehavior"):Connect(function()
        if userInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
            shiftLockEnabled = true
        else
            shiftLockEnabled = false
        end
    end)

    while true do
        task.wait()
        local character = player.Character; if not character then continue end
        local hrp = character:FindFirstChild("HumanoidRootPart"); if not hrp then continue end
        local humanoid = character:FindFirstChild("Humanoid"); if not humanoid then continue end

        local lookVector = hrp.CFrame.LookVector
        local difference = (oldLookVector - lookVector).Magnitude

        if not shiftLockEnabled and lastEnabled then
            angleTick = os.clock()
        end

        if AC_BYPASS then
            if (os.clock() - angleTick < 0.2) and Options.AngleAssist.Value then
                humanoid.JumpPower = (Options.JumpPower.Value and Options.JumpPowerValue.Value or 50) + (Options.AngleAssistJP.Value - 50)
            elseif not Options.AngleAssist.Value then
                humanoid.JumpPower = (Options.JumpPower.Value and Options.JumpPowerValue.Value or 50)
            end
        end

        oldLookVector = hrp.CFrame.LookVector
        lastEnabled = shiftLockEnabled
    end
end)

-- Block extender implementation for practice mode
if AC_BYPASS then
    task.spawn(function()
        while true do
            task.wait()

            local character = player.Character
            local blockPart = character and character:FindFirstChild("BlockPart")

            if not blockPart then continue end

            blockPart.Size = Options.BlockExtender.Value and Vector3.new(Options.BlockExtenderRange.Value, Options.BlockExtenderRange.Value, Options.BlockExtenderRange.Value) or Vector3.new(0.75, 5, 1.5)
            blockPart.Transparency = Options.BlockExtender.Value and Options.BlockExtenderTransparency.Value or 1
        end
    end)
end

-- QuickTP implementation
local quickTPCooldown = os.clock()

userInputService.InputBegan:Connect(function(input, gp)
    if gp then return end

    if not Options.QuickTPBind or not Options.QuickTPBind.Value then return end

    if input.KeyCode ~= Options.QuickTPBind.Value then return end

    local character = player.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    local humanoid = character and character:FindFirstChild("Humanoid")

    if not Options.QuickTP or not Options.QuickTP.Value then return end
    if not character or not humanoidRootPart or not humanoid then return end
    if (os.clock() - quickTPCooldown) < 0.1 then return end

    local speed = 2 + ((Options.QuickTPSpeed and Options.QuickTPSpeed.Value or 3) / 4)

    humanoidRootPart.CFrame += humanoid.MoveDirection * speed
    quickTPCooldown = os.clock()
end)

-- Click tackle aimbot implementation
mouse.Button1Down:Connect(function()
    if not Options.ClickTackleAimbot or not Options.ClickTackleAimbot.Value then return end

    local possessor = findPossessor()
    local character = player.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

    if not character or not humanoidRootPart then return end
    if not possessor or not possessor:FindFirstChild("HumanoidRootPart") then return end

    local distance = (possessor.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
    if not Options.ClickTackleAimbotDistance or distance > Options.ClickTackleAimbotDistance.Value then return end

    humanoidRootPart.CFrame = possessor.HumanoidRootPart.CFrame
end)

-- Walk speed implementation
runService:BindToRenderStep("walkSpeed", Enum.RenderPriority.Character.Value, function()
    local character = player.Character
    local humanoid = character and character:FindFirstChild("Humanoid")

    if not character or not humanoid then return end
    if humanoid:GetState() ~= Enum.HumanoidStateType.Running then return end
    if humanoid.WalkSpeed == 0 and not (Options.NoFreeze and Options.NoFreeze.Value) then return end
    if not character:FindFirstChild("HumanoidRootPart") then return end

    local moveDirection

    if moveToUsing and #moveToUsing > 0 and (os.clock() - (moveToUsing[#moveToUsing] or 0)) < 0.5 then
        pcall(function()
            if humanoid.WalkToPoint and typeof(humanoid.WalkToPoint) == "Vector3" and
               character and character:FindFirstChild("HumanoidRootPart") and
               typeof(character.HumanoidRootPart.Position) == "Vector3" then
                local direction = (humanoid.WalkToPoint - character.HumanoidRootPart.Position)
                if direction.Magnitude > 0 then
                    moveDirection = direction.Unit
                end
            end
        end)
    end

    if not moveDirection then
        moveDirection = humanoid.MoveDirection
    end

    local currentVel = Vector3.new(0, 0, 0)
    pcall(function()
        if character and character:FindFirstChild("HumanoidRootPart") and
           typeof(character.HumanoidRootPart) == "Instance" and
           character.HumanoidRootPart:IsA("BasePart") then
            currentVel = character.HumanoidRootPart:GetVelocity()
        end
    end)

    if (Options.Speed and Options.Speed.Value) or (Options.NoFreeze and Options.NoFreeze.Value) then
        local speedVal = 20

        if Options.Speed and Options.Speed.Value and Options.SpeedValue then
            if type(Options.SpeedValue.Value) == "number" and Options.SpeedValue.Value > 20 then
                speedVal = Options.SpeedValue.Value
            end
        end

        pcall(function()
            if character and character:FindFirstChild("HumanoidRootPart") and
               typeof(character.HumanoidRootPart) == "Instance" and
               character.HumanoidRootPart:IsA("BasePart") then
                local newVelocity = Vector3.new(
                    moveDirection.X * speedVal,
                    currentVel.Y,
                    moveDirection.Z * speedVal
                )
                character.HumanoidRootPart:SetVelocity(newVelocity)
            end
        end)
    end
end)

-- Auto cap implementation
local finishLine = not IS_PRACTICE and workspace.Models.LockerRoomA.FinishLine or Instance.new('Part')

task.spawn(function()
    while true do
        task.wait()
        if not safeIndex(Options.AutoCap, "Value") or not safeIndex(Options.AutoCapEnabled, "Value") then continue end
        if IS_PRACTICE then continue end

        local character = player.Character
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if not hrp then continue end

        if not finishLine or typeof(finishLine) ~= "Instance" then continue end

        local distance
        pcall(function()
            distance = (hrp.Position - finishLine.Position).Magnitude
        end)

        if not distance or distance > 10 then continue end

        local possessor = findPossessor()
        if not possessor then continue end

        local possessorIsLocalPlayer = possessor == character
        if possessorIsLocalPlayer then
            local event = game:GetService("ReplicatedStorage").Remotes.Touchdown
            if event then
                event:FireServer()
            end
        end
    end
end)

-- Periodic character property updates
task.spawn(function()
    while true do
        task.wait(0.5)

        if safeIndex(Options.Speed, "Value") and safeIndex(Options.SpeedValue, "Value") then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid then
                if AC_BYPASS then
                    humanoid.WalkSpeed = Options.SpeedValue.Value
                end
            end
        end

        if safeIndex(Options.JumpPower, "Value") and safeIndex(Options.JumpPowerValue, "Value") then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid and AC_BYPASS then
                humanoid.JumpPower = Options.JumpPowerValue.Value
            end
        end

        if safeIndex(Options.AngleAssist, "Value") and safeIndex(Options.AngleAssistJP, "Value") then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid and AC_BYPASS then
                if os.clock() - (angleTick or 0) < 0.2 then
                    humanoid.JumpPower = Options.AngleAssistJP.Value
                end
            end
        end
    end
end)

-- Final notification and load configuration
Luna:Notification({
    Title = "Eclipse Hub",
    Content = "Script successfully loaded. Enjoy the Script 😉.",
    Icon = "check_circle",
    ImageSource = "Material"
})

-- Load user's saved configuration
Luna:LoadAutoloadConfig()

-- Initialize all UI elements
for flag, element in pairs(Options) do
    if element.Value == nil and element.Default ~= nil then
        if element.Set then
            element:Set(element.Default)
        end
    end
end

-- Final notification and load configuration
Luna:Notification({
    Title = "Eclipse Hub",
    Content = "Script successfully loaded. Enjoy the Script 😉.",
    Icon = "check_circle",
    ImageSource = "Material"
})

-- Load user's saved configuration
Luna:LoadAutoloadConfig()

-- Function to update tabs
local function UpdateTabs()
    for tabName, tab in pairs(Tabs) do
        if tab.RefreshTab then
            tab:RefreshTab()
        end
        print("Refreshed tab:", tabName)
    end
end

-- Call update tabs multiple times to ensure all elements are visible
task.spawn(function()
    wait(1)
    UpdateTabs()

    -- Try refreshing again after a longer delay
    wait(2)
    UpdateTabs()

    -- Try one more time for any remaining elements
    wait(3)
    Luna:Notification({
        Title = "UI Refreshed",
        Content = "All tabs should now be visible",
        Icon = "refresh",
        ImageSource = "Material"
    })
end)

-- Handle Luna UI Library's global state
_G.Luna_ConfigLoaded = true
